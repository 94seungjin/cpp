/*
<문제 14> 표편집

업무용 소프트웨어를 개발하는 니니즈웍스의 인턴인 앙몬드는 명령어 기반으로 표의 행을 선택, 삭제, 복구하는 프로그램을 작성하는 과제를 맡음.
세부 요구사항은 다음과 같다.

행번호	이름
0		무지
1		콘
2		어피치
3		제이지
4		프로도
5		네오
6		튜브
7		라이언

표에서 진하게 칠한 칸은 선택한 행입니다.(현재 2, 어피치가 선택되어있음) 한 번에 한 행만 선택할수 있으며 표의 범위를 벗어날 수 없습니다.
이때 다음과 같은 명령어를 이용해 표를 편집
	- "U X" : 현재 선택한 행에서 X칸 위에 있는 행을 선택
	- "D X" : 현재 선택한 행에서 X칸 아래에 있는 행을 선택
	- "C" : 현재 선택한 행을 삭제한 후, 바로 아래 행을 선택. 단, 삭제된 행이 가장 마지막 행인 경우 바로 윗 행을 선택
	- "Z" : 가장 최근에 삭제한 행을 원래대로 복구. 단, 현재 선택한 행은 바뀌지 않음
예를 들어 위 표에서 "D 2"를 수행하면 (4, 프로도)가 선택되며 "C를 수행하면 선택된 행 삭제하고 바로 아래 행이었던 5, 네오가 적힌 행 선택
다시 "U 3"을 수행한 다음 "C"를 수행한 후의 표 상태는 1번 콘이 선택되고 1번 어피치가 선택됨.
다음으로 "D 4를 수행한 다음 "C"를 수행한 후의 표 상태는 5번 라이언이 선택되고 4번 튜브가 선택됨. 5행이 표의 마지막 행이므로, 이 경우 바로 윗 행 선택하는 점에 주의.
그래서 4, 튜브 선택되어있음.
"U 2"를 수행하면 현재 선택한 행은 2행 제이지
"Z를 수행하면 가장 최근에 제거한 "5, 라이언"이 적힌 행이 복구.
다시 "Z"를 수행하면 그다음으로 제거한 "1, 콘"이 적힌 행이 복구됨. 현재 선택된 행은 바뀌지 않음.

최종 표의 상태와 처음 표의 상태를 비교해 삭제되지 않은 행은 "O", 삭제된 행은 "X"로 표시하면 아래와 같다.
행 번호		이름		비교
0			무지		O
1			콘			O
2			어피치		O
3			제이지		O
4			프로도		X
5			네오		O
6			튜브		O
7			라이언		O

처음 표의 행 개수를 나타내는 정수 n, 처음에 선택한 행위 위치를 나타내는 정수 k, 수행한 명령어들이 담긴 문자열 배열 cmd가 주어질 때,
모든 명령어를 수행한 후의 표의 상태와 처음 표의 상태를 비교해 삭제되지 않은 행은 O, 삭제된 행은 X로 표시해 문자열 형태로 반환하는
solution() 함수를 완성하라.

1. 제약조건
	- 5 <= n <= 1,000,000
	- 0 <= k < n
	- 1 <= cmd의 원소 개수 <= 200,000
		-> cmd의 각 원소는 "U X", "D X", "C", "Z"중 하나
		-> X는 1이상 300,000이하인 자연수이며 0으로 시작하지 않음.
		-> X가 나타내는 자연수에 쉼표는 없음. 예를 들어 123,456가 아니라 123456와 같이 자연수가 주어짐
		-> cmd에 등장하는 모든 X들의 값을 합친 결과가 1,000,000이하인 경우만 입력으로 주어짐.
		-> 표의 모든 행을 제거해 행이 하나도 남지 않는 경우는 입력으로 주어지지 않음
		-> 문제에서 각 행이 제거되고 복구되는 과정을 자연스럽게 보여주기 위해 "이름"이라는 열을 사용했으나, 실제 문제를 푸는 과정에는 필요하지 않음. "이름"열에는 서로 다른 이름들이 중복 없이 채워져 있다고 가정하고 문제 해결.
	- 표의 범위를 벗어나는 이동은 입력으로 주어지지 않음
	- 원래대로 복구할 행이 없을 때, 즉, 삭제한 행이 없을 때 "Z"가 명령어로 주어지는 경우는 없음
	- 정답은 표의 0행부터 n-1행까지에 해당되는 O, X를 순서대로 이어붙인 문자열 형태로 반환

2. 입출력의 예
n	k		cmd																		result	
8	2		["D 2", "C", "U 3", "C", "D 4", "C", "U 2", "Z", "Z"]					"OOOOXOOO"
8	2		["D 2", "C", "U 3", "C", "D 4", "C", "U 2", "Z", "Z", "U 1", "C"]		"OOOOXOOO"

3. 프로토타입
string solution(int n, int k, vector<string> cmd)
*/

#include <string>
#include <vector>
#include <stack>

using namespace std;

string solution(int n, int k, vector<string> cmd) {

    //❶삭제 된 행의 인덱스를 저장 
    stack<int> deleted;
    //❷ 각 행의 위아래에 있는 행의 인덱스를 저장 
    vector<int> up;
    vector<int> down;

    for (int i = 0; i < n + 2; i++) {
        up.push_back(i - 1);
        down.push_back(i + 1);
    }
    //❸ 임시공간을 고려한 현재위치 
    k++;

    //❹ 주어진 명령어를 순회  
    for (int i = 0; i < cmd.size(); i++) {
        //❺ 현재 위치를 삭제하고 그 다음 위치로 이동
        if (cmd[i][0] == 'C') {
            deleted.push(k);
            down[up[k]] = down[k];
            up[down[k]] = up[k];

            if (down[k] == n + 1) k = up[k];
            else k = down[k];
        }

        //❻ 가장 최근에 삭제한 행을 복원
        else if (cmd[i][0] == 'Z') {
            int r = deleted.top();
            down[up[r]] = r;
            up[down[r]] = r;
            deleted.pop();
        }

        //❼  현재 행을 주어진 값 만큼 위혹은 아래로 이동
        else {
            int sz = stoi(cmd[i].substr(2));

            if (cmd[i][0] == 'U') {
                for (int j = 0; j < sz; j++) {
                    k = up[k];
                }
            }

            else if (cmd[i][0] == 'D') {
                for (int j = 0; j < sz; j++) {
                    k = down[k];
                }
            }
        }

    }

    string answer;

    //❽ 삭제된 행의 위치에 “X”, 그렇지 않은 행의 위치에 “X” 로 표시한 문자열 반환
    answer.append(n, 'O');
    while (!deleted.empty()) {
        answer[deleted.top() - 1] = 'X';
        deleted.pop();
    }

    return answer;
}

//아래 코드는 테스트 코드 입니다.
#include <iostream>

int main()
{

    cout << solution(8, 2, { "D 2", "C", "U 3", "C", "D 4", "C", "U 2", "Z", "Z" }) << endl;              //OOOOXOOO
    cout << solution(8, 2, { "D 2", "C", "U 3", "C", "D 4", "C", "U 2", "Z", "Z", "U 1", "C" }) << endl;  //OOXOXOOO
    return 0;
}