/*
요세푸스 문제

N명의 사람이 원 형태로 서 있음. 각 사람은 1부터 N까지 번호표를 갖고 있음.
그리고 임의이 숫자 K가 주어졌을 때 다음과 같이 사람을 없앰
	- 1번 번호표를 가진 사람 기준 시계 방향으로 K번째 사람을 없앰
	- 없앤 사람 다음 사람을 기준으로 하고 다시 K번째 사람을 없앰.

N과 K가 주어질 때 마지막에 살아 있는 사람의 번호를 반환하는 solution()함수를 구현하라

Constrain Condition
	-N과 K는 1이상 1,000이하의 자연수

입출력의 예
N		K		result
5		2		3

분석
	N이 10, K가 2면 1,2까지 가서 2번 제거			-> 1 3 4 5 6 7 8 9 10
	기준점 3번으로 잡히고 4까지 가서 4번 제거		-> 1 3 5 6 7 8 9 10
	기준점 5번으로 잡히고 6까지 가서 6번 제거		-> 1 3 5 7 8 9 10
	기준점 7번으로 잡히고 8까지 가서 8번 제거		-> 1 3 5 7 9 10
	기준점 9번으로 잡히고 10까지 가서 10번 제거		-> 1 3 5 7 9
	기준점 1번으로 잡히고 1번까지 가서 1번 제거		-> 3 5 7 9
	기준점 3번으로 잡히고 5번까지 가서 5번 제거		-> 3 7 9
	기준점 7번으로 잡히고 9번까지 가서 9번 제거		-> 3 7
	기준점 3번으로 잡히고 7번까지 가서 7번 제거		-> 3

프로토타입
int solution(int N, int K)

*/

#include <iostream>
#include <queue>

using namespace std;

int solution(int N, int K)
{
	// 1. 공간 생성
	queue<int> q;

	// 2. 1부터 N까지 번호 큐에 추가
	for (int i = 1; i <= N; i++)
	{
		q.push(i);
	}

	// 3. q에 하나의 요소 남을 때까지 순회
	while (q.size() > 1)
	{
		for (int i = 0; i < K - 1; i++)
		{
			// 4. K번째 사람을 찾기 위해 앞부터 제거하고 뒤에 추가
			q.push(q.front());
			q.pop();
		}
		q.pop();	// 5. K번째 사람 제거
	}

	return q.front();	// 6. 마지막으로 남은 요소 반환
}

int main()
{
	cout << solution(5, 2) << endl;
	return 0;
}

/*
1. 큐에 데이터를 넣겠지 -> push
2. K-1번째까지 데이터 front에서 pop, 그리고 rear에 푸시
3. K번째 데이터 팝하고 출력
4. 큐에 원소 없을 때까지 반복(isEmpty?)
*/